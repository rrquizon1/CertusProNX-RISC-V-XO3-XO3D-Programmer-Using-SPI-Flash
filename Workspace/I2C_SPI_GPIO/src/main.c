// >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
// ------------------------------------------------------------------
// Copyright (c) 2019-2025 by Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// ------------------------------------------------------------------
//
// IMPORTANT: THIS FILE IS USED BY OR GENERATED BY the LATTICE PROPELâ„¢
// DEVELOPMENT SUITE, WHICH INCLUDES PROPEL BUILDER AND PROPEL SDK.
//
// Lattice grants permission to use this code pursuant to the
// terms of the Lattice Propel License Agreement.
//
// DISCLAIMER:
//
//  LATTICE MAKES NO WARRANTIES ON THIS FILE OR ITS CONTENTS, WHETHER
//  EXPRESSED, IMPLIED, STATUTORY, OR IN ANY PROVISION OF THE LATTICE
//  PROPEL LICENSE AGREEMENT OR COMMUNICATION WITH LICENSEE, AND LATTICE 
//  SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTY OF MERCHANTABILITY OR
//  FITNESS FOR A PARTICULAR PURPOSE.  LATTICE DOES NOT WARRANT THAT THE
//  FUNCTIONS CONTAINED HEREIN WILL MEET LICENSEE'S REQUIREMENTS, OR THAT
//  LICENSEE'S OPERATION OF ANY DEVICE, SOFTWARE OR SYSTEM USING THIS FILE
//  OR ITS CONTENTS WILL BE UNINTERRUPTED OR ERROR FREE, OR THAT DEFECTS
//  HEREIN WILL BE CORRECTED.  LICENSEE ASSUMES RESPONSIBILITY FOR 
//  SELECTION OF MATERIALS TO ACHIEVE ITS INTENDED RESULTS, AND FOR THE
//  PROPER INSTALLATION, USE, AND RESULTS OBTAINED THEREFROM.  LICENSEE
//  ASSUMES THE ENTIRE RISK OF THE FILE AND ITS CONTENTS PROVING DEFECTIVE
//  OR FAILING TO PERFORM PROPERLY AND IN SUCH EVENT, LICENSEE SHALL 
//  ASSUME THE ENTIRE COST AND RISK OF ANY REPAIR, SERVICE, CORRECTION, OR
//  ANY OTHER LIABILITIES OR DAMAGES CAUSED BY OR ASSOCIATED WITH THE 
//  SOFTWARE.  IN NO EVENT SHALL LATTICE BE LIABLE TO ANY PARTY FOR DIRECT,
//  INDIRECT,SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST
//  PROFITS, ARISING OUT OF THE USE OF THIS FILE OR ITS CONTENTS, EVEN IF
//  LATTICE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. LATTICE'S
//  SOLE LIABILITY, AND LICENSEE'S SOLE REMEDY, IS SET FORTH ABOVE.  
//  LATTICE DOES NOT WARRANT OR REPRESENT THAT THIS FILE, ITS CONTENTS OR
//  USE THEREOF DOES NOT INFRINGE ON THIRD PARTIES' INTELLECTUAL PROPERTY
//  RIGHTS, INCLUDING ANY PATENT. IT IS THE USER'S RESPONSIBILITY TO VERIFY
//  THE USER SOFTWARE DESIGN FOR CONSISTENCY AND FUNCTIONALITY THROUGH THE
//  USE OF FORMAL SOFTWARE VALIDATION METHODS.
// ------------------------------------------------------------------

#include "uart.h"
#include "gpio.h"
#include "pic.h"
#include "sys_platform.h"
#include "utils.h"
#include <stdio.h>
#include "hal.h"
#include "i2c_master.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "i2c_program.h"
//#include "data.h"
#include "spi_master.h"

struct gpio_instance gpio_test;
struct i2cm_instance i2c_master_test;
struct uart_instance uart_core_uart;
struct spim_instance spi_master_test;

static int lscc_uart_putc(char c, FILE *file)
{
#ifdef LSCC_STDIO_UART_APB
		int ret = EOF;
		ret = uart_putc(&uart_core_uart, c);
		if (c == '\n' && ret == 0)
			ret = uart_putc(&uart_core_uart, '\r');
		return ret;
#else
		return EOF;
#endif
}


static int lscc_uart_getc(FILE *file)
{
	(void) file;
	return EOF;
}


static int lscc_uart_flush(FILE *file)
{
	(void) file;
	return 0;
}


int main(void) {
	static uint8_t idx = 0;
	static uint8_t pin_state = 0xFF;

#if _UART_ENABLE_INTERRUPTS_
	//setup uart IRQ
	pic_init(CPU0_INST_PICTIMER_START_ADDR);
	uart_core_uart.intrLevel = UART0_INST_IRQ;
	pic_isr_register(UART0_INST_IRQ, uart_isr, (void *)&uart_core_uart);
#endif

#ifdef CPU1_INST_NAME
	delayMS(1000);
#endif
#define XO3D_ADDR  0x50        // 7-bit I2C address of XO3D
#define XO3_ADDR 0x40
	//initialize UART
	uart_init(&uart_core_uart, UART0_INST_BASE_ADDR, CPU_FREQUENCY, UART0_INST_BAUD_RATE, 1, 8);
	iob_init(lscc_uart_putc, lscc_uart_getc, lscc_uart_flush);

	printf("%s:Hello RISC-V world!\n",CPU_INST_NAME);

	/*I2c Initialize*/
	i2c_master_config(&i2c_master_test,I2CM_ADDR_7BIT_MODE,INT_MODE,I2C_MASTER_INST_PRESCALER);
	i2c_master_init(&i2c_master_test, I2C_MASTER_INST_BASE_ADDR);


	/*SPI Master initialize*/
	uint32_t tx_buffer[SPI_MASTER_INST_FIFO_DEPTH];
	uint32_t rx_buffer[SPI_MASTER_INST_FIFO_DEPTH];
	spi_master_config(&spi_master_test,
	    SPI_MASTER_INST_DATA_WIDTH,     // data_width = 32 bits
	    SPI_MASTER_INST_PRESCALER,      // prescaler = 18
	    SPI_MASTER_INST_CPOL,           // clk_polarity = 0
	    SPI_MASTER_INST_LSB_FIRST,      // lsb_first = 0 (MSB first)
	    SPI_MASTER_INST_CPHA,           // clk_phase = 0
	    SPI_MASTER_INST_SSNP,           // ssnp = 0
	    SPI_MASTER_INST_ONLY_WRITE,     // only_write = 0 (full duplex)
	    SPI_MASTER_INST_SPI_EN          // spi_en = 0 (disabled)
	);
	spi_master_init(&spi_master_test,SPI_MASTER_INST_BASE_ADDR,SPI_MASTER_INST_SLAVE_COUNT,tx_buffer,rx_buffer,SPI_MASTER_INST_PRESCALER,SPI_MASTER_INST_RX_FIFO_AF_FLAG ,SPI_MASTER_INST_FIFO_DEPTH, SPI_MASTER_INST_FIFO_DEPTH);

	/*GPIO initialize*/
	gpio_init(&gpio_test, GPIO0_INST_BASE_ADDR, GPIO0_INST_LINES_NUM,0x01);



	int CFG=0;
	while (true) {


		spiflash_deviceid(&spi_master_test);
	    i2c_device_id(&i2c_master_test,XO3_ADDR);
	    i2c_device_id(&i2c_master_test,XO3D_ADDR);
	    int CFG=1;
	    i2c_program_XO2_XO3_spiflash(&gpio_test,&i2c_master_test,XO3_ADDR,&spi_master_test, 0x210000,0x216730);
	    i2c_program_XO3D_spiflash(&gpio_test,&i2c_master_test,XO3D_ADDR,&spi_master_test, 0x230000,0x2389E0,CFG);

			exit(0);

	}

	return 0;
}
